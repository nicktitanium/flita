# Документация к телеграм-боту

## Описание

Проект «Электронная очередь по функциональной логике и теории алгоритмов» реализован с помощью библиотеки pyTelegramBotAPI на базе мессенджера Telegram и состоит из двух компонентов: бота и канала. С помощью бота происходит управление электронной очередью, он работает индивидуально для каждого студента, канал является средством публикации обработанных ботом данных и является общим для всех студентов. 

Бот состоит из трех частей:
-	основной файл (“main.py”)

Основной код написан на языке Python и содержит в себе алгоритмы, необходимые для работы бота.
-	конфигурационный файл (“config_tg.py”)

Конфигурационный файл написан на языке Python и содержит в себе некоторые важные неизменяемые в ходе работы программы данные (такие как токен для управления ботом и ссылка на канал) для более удобного доступа к ним. 

-	база данных (“users.db”)

База данных написана на языке SQLite и содержит в себе информацию о студентах

## Взаимодействие с данными на уровне программы:

1. Изменить токен бота:
	Открыть файл config_tg.py и изменить значение переменной token на необходимое

2. Изменить ссылку на канал бота:
	Открыть файл config_tg.py и изменить значение переменной channel_link на необходимое
	После добавить бота в список администраторов канала

## Установка

1. Установите необходимые зависимости:
   
   pip install telebot
   
2. Создайте файл config_tg.py и добавьте в него переменную token, содержащую токен вашего телеграм-бота.

## Использование

1. Запустите бота, выполнив скрипт:
   
   python bot.py

или нажав на кнопку запуска main.py в случае использование PyCharm
   

2. Бот будет отвечать на команды и сообщения от пользователей.

## Команды

- /start - начать взаимодействие с ботом.

## Функции

### Функция start(message)

Эта функция вызывается при получении команды /start. Она выполняет следующие действия:

1. Проверяет, зарегистрирован ли пользователь в базе данных.
2. Если пользователь зарегистрирован, выводит приветственное сообщение и предлагает доступные действия.
3. Если пользователь не зарегистрирован, предлагает пользователю зарегистрироваться.

### Функция menu(message)

Эта функция вызывается при получении сообщения от пользователя. Она выполняет следующие действия:

1. Проверяет, какую команду или сообщение отправил пользователь.
2. Если пользователь не зарегистрирован и отправил сообщение, отличное от "Зарегистрироваться", выводит сообщение об ошибке.
3. Если пользователь зарегистрирован, выполняет следующие действия в зависимости от команды пользователя:
   - "Встать в очередь": добавляет пользователя в очередь и уведомляет администратора.
   - "Отозвать заявку": отзывает заявку пользователя из очереди, если она существует.
   - Любое другое сообщение: выводит сообщение об ошибке.

### Функция reg(message)

Эта функция вызывается при получении сообщения от пользователя после команды "Зарегистрироваться". Она выполняет следующие действия:

1. Проверяет флаг регистрации.
2. Если флаг регистрации активен, получает данные пользователя (фамилию и имя) и добавляет их в базу данных.

## База данных

Бот использует SQLite базу данных users.db, в которой хранятся данные о зарегистрированных пользователях.

### Структура таблицы users

| Колонка | Тип данных |
| ------- | ---------- |
| userid  | INT (PRIMARY KEY) |
| fname   | TEXT |
| lname   | TEXT |

## Подробная информация о коде:

main.py 
--
1. import telebot, import config_tg, import sqlite3, from telebot import types - импортируются необходимые модули и классы для работы с Telegram Bot API и SQLite базой данных.
2. queue = 0, reg_flag = 0, cnt = 0, in_queue = 0 - объявляются переменные с начальными значениями.
3. client = telebot.TeleBot(config_tg.token) - создается экземпляр класса TeleBot с использованием токена бота из конфигурационного файла.
4. times = 0 - объявляется переменная times с начальным значением 0.
5. conn = sqlite3.connect('users.db', check_same_thread=False), cur = conn.cursor() - устанавливается соединение с базой данных SQLite и создается объект cursor для выполнения SQL-запросов.
6. cur.execute("""CREATE TABLE IF NOT EXISTS users(userid INT PRIMARY KEY, fname TEXT, lname TEXT);""") - выполняется SQL-запрос для создания таблицы "users" с тремя столбцами: "userid" (целочисленный первичный ключ), "fname" (текстовый столбец для имени) и "lname" (текстовый столбец для фамилии). Если таблица уже существует, то запрос игнорируется.
7. conn.commit() - фиксируются изменения в базе данных.
8. reg_flag = False - переменная reg_flag устанавливается в значение False.
9. @client.message_handler(commands=["start"]) - декоратор для обработчика команды "/start". Эта функция будет вызвана, когда пользователь отправит команду "/start" боту.
10. def start(message): - определение функции start для обработки команды "/start".
11. user_id = str(message.from_user.id) - получение идентификатора пользователя.
12. if user_id in config_tg.names: - проверка наличия идентификатора пользователя в словаре config_tg.names. Если идентификатор есть в словаре, то выполняются следующие действия.
13. cur.execute("SELECT fname, lname FROM users WHERE userid = ?", (str(message.from_user.id),)) - выполняется SQL-запрос для получения имени и фамилии пользователя из таблицы "users" на основе его идентификатора.
14. result = cur.fetchone() - получение первой строки результата выполнения SQL-запроса.
15. if result != None: - проверка, что результат запроса не является пустым.
16. name = str(result[0] + ' ' + result[1]) - объединение имени и фамилии пользователя в строку.
17. config_tg.list.update({str(message.from_user.id): 0}) - обновление словаря config_tg.list с ключом равным идентификатору пользователя и значением 0.
18. client.send_message(message.chat.id, ...) - отправка сообщения пользователю через бота. Сообщение содержит приветствие и имя пользователя.
19. markup_reply = types.ReplyKeyboardMarkup(resize_keyboard=True) - создание объекта клавиатуры для ответа с возможностью изменения размера.
20. item_add = types.KeyboardButton("Встать в очередь"), item_del = types.KeyboardButton("Отозвать заявку") - создание кнопок для клавиатуры.
21. markup_reply.add(item_add, item_del) - добавление кнопок к клавиатуре.
22. client.send_message(message.chat.id, ...) - отправка сообщения с клавиатурой пользователю.
23. else: - если идентификатор пользователя отсутствует в словаре config_tg.names, то выполняются следующие действия.
24. client.send_message(message.chat.id, ...) - отправка сообщения пользователю о том, что его идентификатор отсутствует в системе.
25. markup_reply = types.ReplyKeyboardMarkup(resize_keyboard=True) - создание объекта клавиатуры для ответа с возможностью изменения размера.
26. item_reg = types.KeyboardButton("Зарегистрироваться") - создание кнопки для клавиатуры.
27. markup_reply.add(item_reg) - добавление кнопки к клавиатуре.
28. client.send_message(message.chat.id, ...) - отправка сообщения с клавиатурой пользователю.
29. @client.message_handler(content_types=['text']) - декоратор для обработчика текстовых сообщений. Эта функция будет вызвана, когда пользователь отправит текстовое сообщение боту.
30. def menu(message): - определение функции menu для обработки текстовых сообщений.
31. if message.text == 'Встать в очередь': - проверка, что текстовое сообщение пользователя равно "Встать в очередь".
32. client.send_message(...) - отправка сообщения в группу с информацией о новой заявке и позиции пользователя в очереди.
33. elif message.text == 'Отозвать заявку': - проверка, что текстовое сообщение пользователя равно "Отозвать заявку".
34. client.send_message(...) - отправка сообщения в группу с информацией об отзыве заявки пользователя.
35. config_tg.list.update({str(message.from_user.id): cnt}) - обновление словаря config_tg.list с ключом равным идентификатору пользователя и значением cnt.
36. if message.text != 'Зарегистрироваться': - проверка, что текстовое сообщение пользователя не равно "Зарегистрироваться".
37. `cur.execute("SELECT fname, lname FROM users WHERE userid = ?", (str(message.from_user.id),))` - выполняется SQL-запрос для получения имени и фамилии пользователя из таблицы "users" на основе его идентификатора.
38. result = cur.fetchone() - получение первой строки результата выполнения SQL-запроса.
39. name = str(result[0] + ' ' + result[1]) - объединение имени и фамилии пользователя в строку.
40. if message.text == 'Встать в очередь': - проверка, что текстовое сообщение пользователя равно "Встать в очередь".
41. if in_queue == 0: - проверка, что пользователь не стоит в очереди.
42. client.send_message(...) - отправка сообщения в группу с информацией о новой заявке и позиции пользователя в очереди.
43. queue += 1 - увеличение переменной queue на 1.
44. in_queue = 1 - установка флага in_queue в значение 1, чтобы отметить, что пользователь стоит в очереди.
45. else: - если пользователь уже стоит в очереди, то выполняются следующие действия.
46. client.send_message(...) - отправка сообщения пользователю о том, что он не может подать заявку, так как уже стоит в очереди.
47. elif message.text == 'Отозвать заявку': - проверка, что текстовое сообщение пользователя равно "Отозвать заявку".
48. if in_queue == 1: - проверка, что пользователь стоит в очереди.
49. client.send_message(...) - отправка сообщения в группу с информацией об отзыве заявки пользователя.
50. queue -= 1 - уменьшение переменной queue на 1.
51. in_queue = 0 - установка флага in_queue в значение 0, чтобы отметить, что пользователь не стоит в очереди.
52. else: - если пользователь не стоит в очереди, то выполняются следующие действия.
53. client.send_message(...) - отправка сообщения пользователю о том, что он не может отозвать заявку, так как не стоит в очереди.
54. elif message.text == 'Зарегистрироваться': - проверка, что текстовое сообщение пользователя равно "Зарегистрироваться".
55. global reg_flag - объявление глобальной переменной reg_flag.
56. reg_flag = 1 - установка переменной reg_flag в значение 1.
57. mesg = client.send_message(...) - отправка сообщения пользователю с просьбой ввести свои данные.
58. client.register_next_step_handler(mesg, reg) - регистрация следующего обработчика для ввода данных пользователем.
59. else: - если текстовое сообщение пользователя не соответствует ни одному из вышеуказанных условий, то выполняются следующие действия.
60. client.send_message(...) - отправка сообщения пользователю с предложением повторить запрос по причине некорректности команды.
61. def reg(message): - объявление функции reg, которая будет вызываться после того, как пользователь введет данные регистрации.
62. global reg_flag - объявление глобальной переменной reg_flag.
63. if reg_flag == 1: - проверка, что reg_flag равно 1.
64. sqlite_insert_with_param = """INSERT OR IGNORE INTO users (userid, fname, lname) VALUES (?, ?, ?);""" - определение SQL-запроса для вставки данных пользователя в таблицу "users".
65. last = message.text.split()[0] - извлечение фамилии пользователя из текстового сообщения, разделенного пробелом, и присвоение значения переменной last.
66. first = message.text.split()[1] - извлечение имени пользователя из текстового сообщения, разделенного пробелом, и присвоение значения переменной first.
67. data_tuple = (str(message.chat.id), first, last) - создание кортежа с данными пользователя.
68. cur.execute(sqlite_insert_with_param, data_tuple) - выполнение SQL-запроса с передачей кортежа данных в качестве параметров.
69. conn.commit() - сохранение изменений в базе данных.
70. markup_reply = types.ReplyKeyboardMarkup(resize_keyboard=True) - создание объекта ReplyKeyboardMarkup для создания кнопок.
71. item_add = types.KeyboardButton("Встать в очередь") - создание кнопки "Встать в очередь".
72. item_del = types.KeyboardButton("Отозвать заявку") - создание кнопки "Отозвать заявку".
73. markup_reply.add(item_add, item_del) - добавление кнопок к клавиатуре markup_reply.
74. client.send_message(...) - отправка сообщения пользователю о успешной регистрации и предложение использовать кнопки для дальнейшего взаимодействия с ботом.
75. client.infinity_polling() - запуск основного цикла бота для обработки входящих сообщений и событий.

config_tg.py
--
1. token = "" - переменная со значением токена для BotFather
2. channel_link = "" - переменная с ссылкой на Telegram-канал бота



